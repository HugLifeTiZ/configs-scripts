#!/bin/bash
# Wait for various different things to fall in place depending on the name of
# this script when it gets run. ln -s this to waitwin, waitproc, waitfile, and
# waitnet to use. It's all kind of hacked together honestly...

cmd=$(basename "$0")

# Support running without a display defined.
if [[ "$cmd" == "waitwin" && -z "$DISPLAY" ]]; then
    export DISPLAY=:0.0
    user="$(who | grep :0\) | cut -d ' ' -f1)"
    export XAUTHORITY="$(cat /etc/passwd | grep $user | cut -d: -f6)/.XAUTHORITY"
fi

waitwin () {
    output=()
    for wid in $(xdotool search $visible $search "$target" || true); do
        if [[ "$old" ]] || xprop -id $wid | grep -qq '^WM_STATE'; then
            output+=($wid)
        fi
    done
    [[ ${#output[@]} -ge $num ]]
}

waitproc ()  { ps aux | egrep -v 'grep|waitproc' | grep "$target"; }
waitfile ()  { [[ -e "$target" ]]; }
waitnet ()   { [[ "$(wget -q -O- http://network-test.debian.org/nm)" \
               == "NetworkManager is online" ]]; }

search="--class"; num=1; timeout=300; delay="0.1"
[[ "$cmd" == "waitnet" ]] && { delay="5"; timeout="64"; }

while getopts actovn:d:T: OPT; do case $OPT in
a) search="--classname" ;;
c) search="--class" ;;
t) search="--name" ;;
v) visible="--onlyvisible" ;;
o) old=1 ;;
n) num="$OPTARG" ;;
T) timeout="$OPTARG" ;;
d) delay="$OPTARG" ;;
esac; done; shift $((OPTIND - 1))

[[ "$cmd" != "waitnet" ]] && { target="$1"; shift; }
while ! $cmd && [[ $timer -lt $timeout ]]; do sleep $delay; ((timer++)); done

if [[ $timer -ge $timeout ]]; then echo "Wait timed out." >&2; exit 1; fi
[[ $# -gt 0 ]] && exec "$@"
[[ ${#output[@]} -gt 0 ]] && echo ${output[@]}
exit 0
