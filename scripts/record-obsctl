#!/bin/sh
# A script to record the screen using obs.
set -eu

info () {
    cat <<EOF
$0: record the screen using obs.
Most configuration should be done inside obs.
Supported options:
    -d|--dir: Output directory for the logfile and the recording.
    -n|--name: Prepend this title before the timestamp.
    -p|--profile: Which OBS profile to start with.
    -q|--quiet: Don't play any defined sounds.
    -w|--wrapper: Prepend a shell-quoted string to the final command.
        A good use of this is schedtool to isolate cores or set niceness.
EOF
}

# Set all variables to default values.
cmd=""
directory="${HOME:?}/Videos/Recordings"
quiet=""
start_sound=""
stop_sound=""
error_sound=""
wrapper=""
no_start=""
intent="auto"


# Convenience functions.
puts () { printf %s\\n "$*"; }
err () { puts "$*" >&2; }
die () { err "$*"; exit 1; }
# shellcheck disable=SC1090
src_opt () { if [ -f "$1" ]; then . "$1"; fi; }
is () {
    case "$(puts "${1:-}" | tr '[:upper:]' '[:lower:]')" in
        yes|on|true) true ;;
        no|off|false) false ;;
        *) [ "${1:-}" -gt 0 ] 2> /dev/null ;;
    esac
}
int () { [ "$1" -eq 0 ] || [ "$1" -ne 0 ] 2> /dev/null; }
aorb () { if is "$1"; then puts "$2"; else puts "$3"; fi; }
snd () { if [ -r "${1:?}" ] && ! is "$quiet"; then play -q -V1 "$1"; fi; }


# Config files are just sourced into here; be responsible.
src_opt "/etc/record.rc"
src_opt "${XDG_CONFIG_HOME:-$HOME/.config}/record.rc"

# Parse the command line.
while [ $# -gt 0 ]; do
    case "$1" in
        -q|--quiet) quiet=yes;;
        -d|--dir|--directory) directory="$2"; shift;;
        -n|--name) name="$2"; shift;;
        -w|--wrapper) wrapper="$2"; shift;;
        --start) intent="start";;
        --stop) intent="stop";;
        *) err "Unrecognized option: $1"; info; die;;
    esac; shift
done

# Stop running instance if invoked with one running.
if [ -w "/run/user/$(id -u)" ]; then pidfile="/run/user/$(id -u)/record.pid"
else pidfile="/tmp/record.pid"; fi

rec_status=$(obsctl --getrecstatus || :)
if [ "$rec_status" = "OBS isn't running." ]; then
    if is "$no_start"; then die "OBS isn't running."; fi
    
    # Find obs.
    if [ ! -x "$cmd" ]; then cmd="$(command -v obs)"; fi
    if [ ! -x "$cmd" ]; then
        if [ -x "$(command -v flatpak)" ] && \
         flatpak run --command=true com.obsproject.Studio; then
            cmd="flatpak run com.obsproject.Studio"
        else die Please put a working obs binary in your PATH.; fi
    else
        # We have to quote it properly in case it exists somewhere with spaces.
        # This string will get passed to eval.
        cmd="\"$cmd\""
    fi
    # Set up other wrappers if requested, like schedtool.
    if [ "$wrapper" ]; then cmd="$wrapper $cmd"; fi
    cmd="$cmd --minimize-to-tray &"
    eval "$cmd"
    echo "$!" > "$pidfile"
    sleep 0.5
    rec_status="Recording: False"
fi

if { [ "$intent" = "auto" ] || [ "$intent" = "stop" ]; } && \
 [ "$rec_status" = "Recording: True" ]; then
    obsctl --stoprec
    sleep 1
    snd "$stop_sound"
    
    # The recording gets moved properly after OBS is stopped.
    output="$(date +%Y%m%d-%H%M%S)"
    if [ "${name:-}" ]; then output="$name $output"; fi
    if [ -e "$directory/00-obs.mkv" ]; then
        mv "$directory/00-obs.mkv" "$directory/$output.mkv"
        #vid-compact --queue "$directory/$output.mkv" || :
    fi
    if [ -e "$pidfile" ]; then
        pid=$(cat "$pidfile")
        rm "$pidfile" || :
        if [ -e "/proc/$pid" ]; then
            kill "$pid"
            sleep 1
        fi
    fi
elif { [ "$intent" = "auto" ] || [ "$intent" = "start" ]; } && \
 [ "$rec_status" = "Recording: False" ]; then
    # Notify of record start.
    snd "$start_sound"
    puts "Starting capture."
    obsctl --startrec
    status=$?
    sleep 1
    if [ "$status" -ne 0 ]  || \
     [ "$(obsctl --getrecstatus)" != "Recording: True" ]; then
        err "Recording start failed for some reason."
        snd "$error_sound"
        rm "$pidfile" || :
    fi
fi
